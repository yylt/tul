

pub mod tj;
pub mod websocket;
pub mod api;
pub mod dns;

use regex::Regex;
use std::net::{Ipv4Addr, Ipv6Addr};
use std::collections::{HashSet};

use worker::*;
use sha2::{Sha224, Digest};
use tokio::{sync::OnceCell};
use std::io::{
    Error,
    ErrorKind,
};

static EXPECTED_HASH: OnceCell<Vec<u8>> = OnceCell::const_new();
static BUFSIZE: OnceCell<usize> = OnceCell::const_new();
static APIREGEX: OnceCell<Regex> = OnceCell::const_new();
static PREFIXTJ: OnceCell<String> = OnceCell::const_new();
static DOH_HOST: OnceCell<String> = OnceCell::const_new();
static HOP_HEADERS: OnceCell<HashSet<String>> = OnceCell::const_new();

#[derive(Debug, Clone)]
pub enum Address {
    Ipv4(Ipv4Addr),
    Ipv6(Ipv6Addr),
    Domain(String),
}

impl Into<String> for Address {
    fn into(self) -> String {
        match self {
            Address::Ipv4(ip) => ip.to_string(),
            Address::Ipv6(ip) => ip.to_string(),
            Address::Domain(domain) => domain,
        }
    }
}

async fn get_hop_headers() -> HashSet<String> {
    let mut headers = HashSet::new();
    
    // RFC 2616 
    headers.insert("connection".to_string());
    headers.insert("keep-alive".to_string());
    headers.insert("proxy-authenticate".to_string());
    headers.insert("proxy-authorization".to_string());
    headers.insert("te".to_string());
    headers.insert("trailer".to_string());
    headers.insert("transfer-encoding".to_string());
    headers.insert("upgrade".to_string());
    
    // generated by proxy
    headers.insert("x-forwarded-for".to_string());
    headers.insert("x-forwarded-host".to_string());
    headers.insert("x-forwarded-proto".to_string());
    headers.insert("x-real-ip".to_string());
    headers.insert("via".to_string());
    headers.insert("x-forwarded-port".to_string());
    headers.insert("x-forwarded-server".to_string());

    // Cloudflare headers
    //headers.insert("cf-connecting-ip".to_string()); // use this otherwise visit cf-cdn blocked.
    headers.insert("cf-ray".to_string());
    headers.insert("cf-ipcountry".to_string());
    headers.insert("cf-request-id".to_string());

    // content had decoded
    headers.insert("content-encoding".to_string());

    headers
}

async fn get_prefix_trojan(cx: &RouteContext<()>) -> String {
    let pre = cx.env
        .secret("PREFIX")
        .map_or("/tj".to_string(), |x| x.to_string());
    if ! pre.starts_with("/") {
        return format!("/{}", pre);
    }
    pre
}

async fn get_regex() -> Regex {
    regex::Regex::new(r"^/(?P<domain>[^/]+)(?P<path>/[^?]*)?$").unwrap()
}

async fn get_expected_hash(cx: &RouteContext<()>) -> Vec<u8> {
    let pw = cx.env
        .secret("PASSWORD")
        .map_or("password".to_string(), |x| x.to_string());
    Sha224::digest(pw.as_bytes())
        .iter()
        .map(|x| format!("{:02x}", x))
        .collect::<String>()
        .as_bytes()
        .to_vec()
}

async fn get_bufsize(cx: &RouteContext<()>) -> usize {
    cx.env.var("BUFSIZE")
    .map_or(2048, |x| x.to_string().parse::<usize>().unwrap_or(2048))
}

pub async fn get_doh_host(cx: &RouteContext<()>) -> String {
    cx.env
        .var("DOH_HOST")
        .map_or("tul.yylt.site".to_string(), |x| x.to_string())
}

pub async fn handler(req: Request, cx: RouteContext<()>) -> Result<Response> {
    let tj_prefix = PREFIXTJ.get_or_init(|| async {
        get_prefix_trojan(&cx).await
    }).await;
    let dns_host = DOH_HOST.get_or_init(|| async {
        get_doh_host(&cx).await
    }).await;
    
    let query = match req.url() {
        Ok(url) => url.query().and_then(|x| Some(x.to_string())),
        Err(_) => None,
    };

    match req.path().as_str() {
        "/dns-query" | "/resolve"=> dns::resolve_handler(req, dns_host, query).await,
        path if path.starts_with(tj_prefix.as_str()) => tj(req, cx).await,
        path if path.starts_with("/v2") => api::image_handler(req).await,
        _ => {
            let reg = APIREGEX.get_or_init(|| async {
                get_regex().await
            }).await;
            
            if let Some(captures) = reg.captures(req.path().as_str()) {
                let domain = captures.name("domain").map_or("", |x| x.as_str());
                let path = captures.name("path").map_or("", |x| x.as_str());

                if !domain.contains('.') {
                    return Response::error("Not Found", 404);
                }
                let mut url = format!("https://{}{}", domain, path);
                if let Some(v) = query {
                    url.push('?');
                    url.push_str(&v);
                }
                
                if let Ok(url) = Url::parse(&url) {                   
                    return api::handler(req,  url).await;
                }
            }
            return Response::error( "Not Found",404);
        }
    }   
}

pub async fn tj(_req: Request, cx: RouteContext<()>) -> Result<Response> {
    
    let expected_hash = EXPECTED_HASH.get_or_init(|| async {
        get_expected_hash(&cx).await
    }).await;
    let buf_size = *BUFSIZE.get_or_init(|| async {
        get_bufsize(&cx).await
    }).await;
    let dns_host = DOH_HOST.get_or_init(|| async {
        get_doh_host(&cx).await
    }).await;
    
    let WebSocketPair { server, client } = WebSocketPair::new()?;
    let response = Response::from_websocket(client)?;
    // cloudflare not support early data!
    server.accept()?;
    wasm_bindgen_futures::spawn_local(async move {
        let events = server.events().expect("Failed to get event stream");
        let mut wsstream = websocket::WsStream::new(
            &server,
            events,
            buf_size,
            None,
            );

        let result = match tj::parse(expected_hash,&mut wsstream).await {
            Ok((hostname, port)) => {
                match dns::is_cf_address(&hostname, dns_host).await {
                    Ok(true) => {
                        console_debug!("DNS query success, behind cloudflare for {:?}", &hostname);
                        //server.close(Some(1000u16), Some("use DoH then connect directly")).ok();
                        let _ = server.close(Some(1000u16), Some("Cloudflare Host not allowed, use DoH then connect directly"));
                        return; 
                    }
                    Ok(false) => {},
                    Err(e) => {
                        console_error!("DNS query failed for {:?}: {}", &hostname, e);
                    }
                }
                match Socket::builder().connect(hostname, port) {
                    Ok(mut upstream) => {
                        match tokio::io::copy_bidirectional(wsstream.as_mut(),&mut upstream).await {
                            Ok(_) => Ok(()),
                            Err(e) => {
                                console_error!("forward failed: {}", e);
                                Err(e)
                            }
                        }
                    }
                    Err(e) => {
                        console_error!("connect failed: {}", e);
                        Err(Error::new(ErrorKind::Other, e))
                    }
                }                       
            },
            Err(e) => {
                console_error!("parse request failed: {}", e);
                Err(e)
            }
        };
        if let Err(_e) = result {
             server.close(Some(1011u16), Some("Internal error or connection failure")).ok();
        } else {
             server.close(Some(1000u16), Some("Normal closure")).ok();
        }
    });
    Ok(response)
}
