

pub mod tj;
pub mod websocket;
pub mod api;
pub mod dns;
use worker::*;
use std::collections::{
    HashMap,
    HashSet,
};
use std::net::Ipv4Addr;
use fast_radix_trie::RadixSet;
use sha2::{Sha224, Digest};
use tokio::{sync::OnceCell};


#[allow(dead_code)]
static PROXY_DOMAINS: OnceCell<RadixSet> = OnceCell::const_new();

// address array, which support forward by host header.
#[allow(dead_code)]
static FORWARD_HOST: OnceCell<Option<String>> = OnceCell::const_new();

// one hop header, which should remove when forward.
static HOP_HEADERS: OnceCell<HashSet<String>> = OnceCell::const_new();

// trojan password hash
static TJ_PASSWORD: OnceCell<Vec<u8>> = OnceCell::const_new();

// trojan on ws, the prefix path 
static TJ_PATH: OnceCell<String> = OnceCell::const_new();

// suport DoH domain, like 1.1.1.1, doh.pub
static DOH_HOST: OnceCell<String> = OnceCell::const_new();
static COOKIE_HOST_KEY: &str = "tul_host";

#[derive(Debug, Clone)]
pub enum Address<T: AsRef<str>> {
    Ipv4(Ipv4Addr),
    Domain(T),
}


// when destinatin use CF 5s or check referer, also could not be access too.
#[allow(dead_code)]
async fn get_proxy_domains(cx: &RouteContext<()>) -> RadixSet {
    let mut set = RadixSet::new();
    if let Ok(x) = cx.env.secret("PROXY_DOMAINS") {
        x.to_string().split(",")
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .map(|s| s.chars().rev().collect::<String>())
            .for_each(|s| {set.insert(s.into_bytes());});
    }
    set
}

// forward host must be domain, and forbid ip.
// http only support 80, https only support 443
#[allow(dead_code)]
async fn get_forward_host(cx: &RouteContext<()>) -> Option<String> {
    cx.env
        .secret("FORWARD_HOST")
        .ok()
        .and_then(|x| {
            let s = x.to_string();
            let mut parts = s.trim().split(':');
            parts.next().and_then(|host| {
                let port = parts.next().map_or(80, |p| p.parse::<u16>().unwrap_or(80));

                Socket::builder()
                    .connect(host, port)
                    .ok()
                    .map(|_| x.to_string())
            })
        })
}

async fn get_hop_headers() -> HashSet<String> {
    let mut headers = HashSet::new();
    
    // RFC 2616 
    headers.insert("connection".to_string());
    headers.insert("keep-alive".to_string());
    headers.insert("proxy-authenticate".to_string());
    headers.insert("proxy-authorization".to_string());
    headers.insert("te".to_string());
    headers.insert("trailer".to_string());
    headers.insert("transfer-encoding".to_string());
    headers.insert("upgrade".to_string());
    
    // generated by proxy
    headers.insert("x-forwarded-for".to_string());
    headers.insert("x-forwarded-host".to_string());
    headers.insert("x-forwarded-proto".to_string());
    headers.insert("x-real-ip".to_string());
    headers.insert("via".to_string());
    headers.insert("x-forwarded-port".to_string());
    headers.insert("x-forwarded-server".to_string());

    // Cloudflare headers
    //headers.insert("cf-connecting-ip".to_string()); // use this otherwise visit cf-cdn blocked.
    headers.insert("cf-ray".to_string());
    headers.insert("cf-ipcountry".to_string());
    headers.insert("cf-request-id".to_string());

    headers
}

async fn get_trojan_path(cx: &RouteContext<()>) -> String {
    let pre = cx.env
        .secret("PREFIX")
        .map_or("/tj".to_string(), |x| x.to_string());
    if ! pre.starts_with("/") {
        return format!("/{}", pre);
    }
    pre
}

async fn get_trojan_password(cx: &RouteContext<()>) -> Vec<u8> {
    let pw = cx.env
        .secret("PASSWORD")
        .map_or("password".to_string(), |x| x.to_string());
    Sha224::digest(pw.as_bytes())
        .iter()
        .map(|x| format!("{:02x}", x))
        .collect::<String>()
        .as_bytes()
        .to_vec()
}

async fn get_doh_host(cx: &RouteContext<()>) -> String {
    cx.env
        .var("DOH_HOST")
        .map_or("1.1.1.1".to_string(), |x| x.to_string())
}

// parse path：{domain}:{port}{path}
fn parse_path(url: &str) -> (Option<&str>, Option<&str>, Option<&str>) {
    if !url.starts_with('/') || url.len() == 1 {
        return (None, None, None);
    }
    
    let rest = &url[1..];
    
    let domain_end = rest.find([':', '/']).unwrap_or(rest.len());
    let domain = &rest[..domain_end];
    
    if domain.is_empty() {
        return (None, None, None);
    }
    
    let remaining = &rest[domain_end..];
    
    if remaining.is_empty() {
        return (Some(domain), None, None);
    }
    
    if let Some(stripped) = remaining.strip_prefix(':') {
        if let Some(path_start) = stripped.find('/') {
            let port = &stripped[..path_start];
            let path = &stripped[path_start..];
            (Some(domain), Some(port), Some(path))
        } else {
            (Some(domain), Some(stripped), None)
        }
    } else {
        (Some(domain), None, Some(remaining))
    }
}


fn get_cookie_by_name(cookie_str: &str, key: &str) -> Option<String> {
    cookie_str
        .split(';')
        .filter_map(|cookie| {
            let (cookie_key, cookie_value) = cookie.trim().split_once('=')?;
            Some((cookie_key, cookie_value))
        })
        .find(|(k, _)| *k == key)
        .map(|(_, v)| v.to_string())
}

pub async fn handler(req: Request, cx: RouteContext<()>) -> Result<Response> {
    let tj_path = TJ_PATH.get_or_init(|| async {
        get_trojan_path(&cx).await
    }).await;
    let dns_host = DOH_HOST.get_or_init(|| async {
        get_doh_host(&cx).await
    }).await;
    
    let query = req
        .query()
        .map_or(None, |q: HashMap<String, String>| Some(q));
    let origin_path = req.path();

    match origin_path.as_str() {
        "/dns-query" => dns::resolve_handler(req, dns_host, query).await,
        path if path.starts_with(tj_path.as_str()) => tj(req, cx).await,
        path if path.starts_with("/v2") => api::image_handler(req, query).await,
        _ => {
            let cookie_host = req.headers().get("cookie")?
                .and_then(|cookie| get_cookie_by_name(&cookie, COOKIE_HOST_KEY));

            let (mut domain, port, mut path) = parse_path(&origin_path);
            // when not resolve, will try find domain by cookie.
            let mut notresolve= true;
            // when only domain, will update cookie in response.
            let mut onlydomain = false;
            let scheme = "https";
            
            match domain {
                Some(d) if d.contains('.') => {
                    if (dns::is_cf_address(&Address::Domain(d)).await).is_ok() {
                        notresolve = false;
                        if path.is_none() || path.as_ref().unwrap().len()<2 {
                            onlydomain = true;
                        }
                    }
                },
                _ => {},
            }

            match (notresolve, &cookie_host) {
                (true, Some(host)) => {
                    domain = Some(host.as_ref());  
                    path = Some(origin_path.as_str());
                }
                (true, None) => return Response::error("Not Found", 404),
                (false, _) => {},
            }

            let host = domain.unwrap();
            
            console_debug!("finally scheme: {:?}, host: {:?}, port: {:?}, path: {:?}, query: {:?}", 
                scheme, host, port, path, query);

            let mut url = match (port, path) {
                (Some(p), Some(path)) => format!("{}://{}:{}{}", scheme, host, p, path),
                (Some(p), None) => format!("{}://{}:{}", scheme, host, p),
                (None, Some(path)) => format!("{}://{}{}", scheme, host, path),
                (None, None) => format!("{}://{}", scheme, host),
            };
            if let Some(v) = query {
                url.push('?');
                url.push_str(v.iter()
                    .map(|(k, v)| format!("{}={}", k, v))
                    .collect::<Vec<_>>()
                    .join("&")
                    .as_str());
            }
            let mut resp = api::handler(req,  Url::parse(&url)?, host).await?;
            match resp.headers().get("content-type")? {
                Some(s) if s.contains("text/html") => {
                    if onlydomain {
                        console_debug!("set cookie domain: {:?}", host);
                        let _ = resp.headers_mut()
                            .set("set-cookie", format!("{}={}; Path=/; Max-Age=3600", COOKIE_HOST_KEY, host).as_str());
                    }
                }
                _ => {}
            }
            Ok(resp)    
        }
    }   
}

pub async fn tj(_req: Request, cx: RouteContext<()>) -> Result<Response> {
    let expected_hash = TJ_PASSWORD.get_or_init(|| async {
        get_trojan_password(&cx).await
    }).await;
    
    let WebSocketPair { server, client } = WebSocketPair::new()?;
    let response = Response::from_websocket(client)?;
    // cloudflare not support early data!
    server.accept()?;
    wasm_bindgen_futures::spawn_local(async move {
        let events = server.events().expect("Failed to get event stream");
        let mut wsstream = websocket::WsStream::new(
            &server,
            events,
            None,
            );

        let result = match tj::parse(expected_hash,&mut wsstream).await {
            Ok((hostname, port)) => {
                let addr = match dns::is_cf_address(&hostname).await {
                    Ok((true,_)) => {
                        console_debug!("DNS query success, behind cloudflare for {:?}", &hostname);
                        //server.close(Some(1000u16), Some("use DoH then connect directly")).ok();
                        None
                    }
                    Ok((false, ip)) => Some(ip),
                    Err(e) => {
                        console_error!("DNS query failed for {:?}: {}", &hostname, e);
                        None
                    }
                };
                let host = match addr {
                    Some(ip) => ip.to_string(),
                    None => {
                        let _ = server.close(Some(1000u16), Some("Normal closure"));
                        return;
                    },
                };
                match Socket::builder().connect(host, port) {
                    Ok(mut upstream) => {
                        match tokio::io::copy_bidirectional(wsstream.as_mut(),&mut upstream).await {
                            Ok(_) => Ok(()),
                            Err(e) => {
                                console_error!("forward failed: {}", e);
                                Err(Error::Io(e))
                            }
                        }
                    }
                    Err(e) => {
                        console_error!("connect failed: {}", e);
                        Err(e)
                    }
                }                       
            },
            Err(e) => {
                console_error!("parse request failed: {}", e);
                Err(Error::Io(e))
            }
        };
        if let Err(_e) = result {
             server.close(Some(1011u16), Some("Internal error or connection failure")).ok();
        } else {
             server.close(Some(1000u16), Some("Normal closure")).ok();
        }
    });
    Ok(response)
}


#[test]
fn test_parse_path() {
    let test_cases = [
        "/a:100/b/c",
        "/example.com",
        "/example.com:8080", 
        "/example.com/path",
        "/example.com:8080/path/to/resource",
        "/a/b/c",
        "/",
        "invalid",
        "/github.githubassets.com/assets/wp-runt",  // 边界情况
    ];
    
    eprintln!("Testing fixed version:");
    for case in test_cases {
        let (domain, port, path) = parse_path(case);
        eprintln!("{:20} -> domain: {:10?} port: {:6?} path: {:?}", 
                 case, domain, port, path);
    }
}

#[test]
fn test_proxy_domains() {

}