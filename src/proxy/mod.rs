pub mod api;
pub mod dns;
pub mod tj;
pub mod websocket;
use fast_radix_trie::RadixSet;
use sha2::{Digest, Sha224};
use std::collections::{HashMap, HashSet};
use std::net::Ipv4Addr;
use tokio::sync::OnceCell;
use worker::*;

#[allow(dead_code)]
static PROXY_DOMAINS: OnceCell<RadixSet> = OnceCell::const_new();

// address array, which support forward by host header.
#[allow(dead_code)]
static FORWARD_HOST: OnceCell<Option<String>> = OnceCell::const_new();

// one hop header, which should remove when forward.
static HOP_HEADERS: OnceCell<HashSet<String>> = OnceCell::const_new();

// trojan password hash
static TJ_PASSWORD: OnceCell<Vec<u8>> = OnceCell::const_new();

// trojan on ws, the prefix path
static TJ_PATH: OnceCell<String> = OnceCell::const_new();

// suport DoH domain, like 1.1.1.1, doh.pub, dns.google
static DOH_HOST: OnceCell<String> = OnceCell::const_new();
static COOKIE_HOST_KEY: &str = "tul_host";

#[derive(Debug, Clone)]
pub enum Address<T: AsRef<str>> {
    Ipv4(Ipv4Addr),
    Domain(T),
}

// when destinatin use CF 5s or check referer, also could not be access too.
#[allow(dead_code)]
async fn get_proxy_domains(cx: &RouteContext<()>) -> RadixSet {
    let mut set = RadixSet::new();
    if let Ok(x) = cx.env.secret("PROXY_DOMAINS") {
        x.to_string()
            .split(",")
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .map(|s| s.chars().rev().collect::<String>())
            .for_each(|s| {
                set.insert(s.into_bytes());
            });
    }
    set
}

// forward host must be domain, and forbid ip.
// http only support 80, https only support 443
#[allow(dead_code)]
async fn get_forward_host(cx: &RouteContext<()>) -> Option<String> {
    cx.env.secret("FORWARD_HOST").ok().and_then(|x| {
        let s = x.to_string();
        let mut parts = s.trim().split(':');
        parts.next().and_then(|host| {
            let port = parts.next().map_or(80, |p| p.parse::<u16>().unwrap_or(80));

            Socket::builder()
                .connect(host, port)
                .ok()
                .map(|_| x.to_string())
        })
    })
}

async fn get_hop_headers() -> HashSet<String> {
    let mut headers = HashSet::new();

    // RFC 2616
    headers.insert("connection".to_string());
    headers.insert("keep-alive".to_string());
    headers.insert("proxy-authenticate".to_string());
    headers.insert("proxy-authorization".to_string());
    headers.insert("te".to_string());
    headers.insert("trailer".to_string());
    headers.insert("transfer-encoding".to_string());
    headers.insert("upgrade".to_string());

    // generated by proxy
    headers.insert("x-forwarded-for".to_string());
    headers.insert("x-forwarded-host".to_string());
    headers.insert("x-forwarded-proto".to_string());
    headers.insert("x-real-ip".to_string());
    headers.insert("via".to_string());
    headers.insert("x-forwarded-port".to_string());
    headers.insert("x-forwarded-server".to_string());

    // Cloudflare headers
    //headers.insert("cf-connecting-ip".to_string()); // use this otherwise visit cf-cdn blocked.
    headers.insert("cf-ray".to_string());
    headers.insert("cf-ipcountry".to_string());
    headers.insert("cf-request-id".to_string());

    headers
}

async fn get_trojan_path(cx: &RouteContext<()>) -> String {
    let pre = cx
        .env
        .secret("PREFIX")
        .map_or("/tj".to_string(), |x| x.to_string());
    if !pre.starts_with("/") {
        return format!("/{}", pre);
    }
    pre
}

async fn get_trojan_password(cx: &RouteContext<()>) -> Vec<u8> {
    let pw = cx
        .env
        .secret("PASSWORD")
        .map_or("password".to_string(), |x| x.to_string());
    Sha224::digest(pw.as_bytes())
        .iter()
        .map(|x| format!("{:02x}", x))
        .collect::<String>()
        .as_bytes()
        .to_vec()
}

async fn get_doh_host(cx: &RouteContext<()>) -> String {
    cx.env
        .var("DOH_HOST")
        .map_or("dns.google".to_string(), |x| x.to_string())
}

// parse pathï¼š[{scheme}://]{domain}:{port}{path}
fn parse_path(url: &str) -> (&str, Option<&str>, Option<&str>, Option<&str>) {
    if !url.starts_with('/') || url.len() == 1 {
        return ("https", None, None, None);
    }

    let mut scheme = "https";
    let mut rest = &url[1..];
    if let Some(idx) = rest.find("://") {
        // ensure scheme part is non-empty and alphabetic to avoid false positives
        let scheme_candidate = &rest[..idx];
        if !scheme_candidate.is_empty() && scheme_candidate.chars().all(|c| c.is_ascii_alphabetic())
        {
            let trimmed = &rest[idx + 3..];
            if trimmed.is_empty() {
                return (scheme_candidate, None, None, None);
            }
            rest = trimmed;
            scheme = scheme_candidate;
        }
    }

    let domain_end = rest.find([':', '/']).unwrap_or(rest.len());
    let domain = &rest[..domain_end];

    if domain.is_empty() {
        return (scheme, None, None, None);
    }

    let remaining = &rest[domain_end..];

    if remaining.is_empty() {
        return (scheme, Some(domain), None, None);
    }

    if let Some(stripped) = remaining.strip_prefix(':') {
        if let Some(path_start) = stripped.find('/') {
            let port = &stripped[..path_start];
            let path = &stripped[path_start..];
            (scheme, Some(domain), Some(port), Some(path))
        } else {
            (scheme, Some(domain), Some(stripped), None)
        }
    } else {
        (scheme, Some(domain), None, Some(remaining))
    }
}

fn get_cookie_by_name(cookie_str: &str, key: &str) -> Option<String> {
    cookie_str
        .split(';')
        .filter_map(|cookie| {
            let (cookie_key, cookie_value) = cookie.trim().split_once('=')?;
            Some((cookie_key, cookie_value))
        })
        .find(|(k, _)| *k == key)
        .map(|(_, v)| v.to_string())
}

pub async fn handler(req: Request, cx: RouteContext<()>) -> Result<Response> {
    let tj_path = TJ_PATH
        .get_or_init(|| async { get_trojan_path(&cx).await })
        .await;
    let dns_host = DOH_HOST
        .get_or_init(|| async { get_doh_host(&cx).await })
        .await;

    let query = req
        .query()
        .map_or(None, |q: HashMap<String, String>| Some(q));
    let origin_path = req.path();

    match origin_path.as_str() {
        "/dns-query" => dns::resolve_handler(req, dns_host, query).await,
        path if path.starts_with(tj_path.as_str()) => tj(req, cx).await,
        path if path.starts_with("/v2") => api::image_handler(req, query).await,
        _ => {
            let cookie_host = req
                .headers()
                .get("cookie")?
                .and_then(|cookie| get_cookie_by_name(&cookie, COOKIE_HOST_KEY));

            let (scheme, mut domain, port, mut path) = parse_path(&origin_path);

            // when not resolve, will try find domain by cookie.
            let resolve = match domain {
                Some(d) => {
                    d.contains('.')
                        && dns::is_cf_address(dns_host, &Address::Domain(d))
                            .await
                            .is_ok()
                }
                _ => false,
            };
            console_debug!(
                "domain: {:?}, path: {:?}, resolved: {:?}",
                domain,
                path,
                resolve
            );
            match (resolve, &cookie_host) {
                (false, Some(host)) => {
                    domain = Some(host.as_ref());
                    path = Some(origin_path.as_str());
                }
                (false, None) => return Response::error("Not Found", 404),
                (true, _) => {}
            }

            let host = domain.unwrap();

            console_debug!(
                "finally scheme: {:?}, host: {:?}, port: {:?}, path: {:?}, query: {:?}",
                scheme,
                host,
                port,
                path,
                query
            );

            let mut url = match (port, path) {
                (Some(p), Some(path)) => format!("{}://{}:{}{}", scheme, host, p, path),
                (Some(p), None) => format!("{}://{}:{}", scheme, host, p),
                (None, Some(path)) => format!("{}://{}{}", scheme, host, path),
                (None, None) => format!("{}://{}", scheme, host),
            };
            if let Some(v) = query {
                url.push('?');
                url.push_str(
                    v.iter()
                        .map(|(k, v)| format!("{}={}", k, v))
                        .collect::<Vec<_>>()
                        .join("&")
                        .as_str(),
                );
            }
            api::handler(req, Url::parse(&url)?, host).await
        }
    }
}

pub async fn tj(_req: Request, cx: RouteContext<()>) -> Result<Response> {
    let expected_hash = TJ_PASSWORD
        .get_or_init(|| async { get_trojan_password(&cx).await })
        .await;
    let dns_host = DOH_HOST
        .get_or_init(|| async { get_doh_host(&cx).await })
        .await;

    let WebSocketPair { server, client } = WebSocketPair::new()?;
    let response = Response::from_websocket(client)?;
    // cloudflare not support early data!
    server.accept()?;
    wasm_bindgen_futures::spawn_local(async move {
        let events = server.events().expect("Failed to get event stream");
        let mut wsstream = websocket::WsStream::new(&server, events, None);

        let result = match tj::parse(expected_hash, &mut wsstream).await {
            Ok((hostname, port)) => {
                let addr = match dns::is_cf_address(dns_host, &hostname).await {
                    Ok((true, _)) => {
                        console_debug!("DNS query success, behind cloudflare for {:?}", &hostname);
                        //server.close(Some(1000u16), Some("use DoH then connect directly")).ok();
                        None
                    }
                    Ok((false, ip)) => Some(ip),
                    Err(e) => {
                        console_error!("DNS query failed for {:?}: {}", &hostname, e);
                        None
                    }
                };
                let host = match addr {
                    Some(ip) => ip.to_string(),
                    None => {
                        let _ = server.close(Some(1000u16), Some("Normal closure"));
                        return;
                    }
                };
                match Socket::builder().connect(host, port) {
                    Ok(mut upstream) => {
                        match tokio::io::copy_bidirectional(wsstream.as_mut(), &mut upstream).await
                        {
                            Ok(_) => Ok(()),
                            Err(e) => {
                                console_error!("forward failed: {}", e);
                                Err(Error::Io(e))
                            }
                        }
                    }
                    Err(e) => {
                        console_error!("connect failed: {}", e);
                        Err(e)
                    }
                }
            }
            Err(e) => {
                console_error!("parse request failed: {}", e);
                Err(Error::Io(e))
            }
        };
        if let Err(_e) = result {
            server
                .close(Some(1011u16), Some("Internal error or connection failure"))
                .ok();
        } else {
            server.close(Some(1000u16), Some("Normal closure")).ok();
        }
    });
    Ok(response)
}

#[test]
fn test_parse_path() {
    let test_cases = [
        ("/a:100/b/c", "https", Some("a"), Some("100"), Some("/b/c")),
        ("/example.com", "https", Some("example.com"), None, None),
        (
            "/example.com:8080",
            "https",
            Some("example.com"),
            Some("8080"),
            None,
        ),
        (
            "/example.com/path",
            "https",
            Some("example.com"),
            None,
            Some("/path"),
        ),
        (
            "/example.com:8080/path/to/resource",
            "https",
            Some("example.com"),
            Some("8080"),
            Some("/path/to/resource"),
        ),
        (
            "/https://example.com:8443/api",
            "https",
            Some("example.com"),
            Some("8443"),
            Some("/api"),
        ),
        (
            "/http://example.com/resource",
            "http",
            Some("example.com"),
            None,
            Some("/resource"),
        ),
        (
            "/https://example.com",
            "https",
            Some("example.com"),
            None,
            None,
        ),
        ("/a/b/c", "https", Some("a"), None, Some("/b/c")),
        ("/", "https", None, None, None),
        ("invalid", "https", None, None, None),
        (
            "/github.githubassets.com/assets/wp-runt",
            "https",
            Some("github.githubassets.com"),
            None,
            Some("/assets/wp-runt"),
        ),
    ];

    for (input, expected_scheme, expected_domain, expected_port, expected_path) in test_cases {
        let (scheme, domain, port, path) = parse_path(input);
        assert_eq!(
            (scheme, domain, port, path),
            (
                expected_scheme,
                expected_domain,
                expected_port,
                expected_path
            ),
            "parse_path failed for input {}",
            input
        );
    }
}

#[test]
fn test_proxy_domains() {}
