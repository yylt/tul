
use worker::*;
use std::collections::{HashSet, HashMap};
use tokio::{sync::OnceCell};

static HOP_HEADERS: OnceCell<HashSet<String>> = OnceCell::const_new();
static REGISTRY: &str = "registry-1.docker.io";


async fn get_hop_headers() -> HashSet<String> {
    let mut headers = HashSet::new();
    
    // RFC 2616 
    headers.insert("connection".to_string());
    headers.insert("keep-alive".to_string());
    headers.insert("proxy-authenticate".to_string());
    headers.insert("proxy-authorization".to_string());
    headers.insert("te".to_string());
    headers.insert("trailer".to_string());
    headers.insert("transfer-encoding".to_string());
    headers.insert("upgrade".to_string());
    
    // generated by proxy
    headers.insert("x-forwarded-for".to_string());
    headers.insert("x-forwarded-host".to_string());
    headers.insert("x-forwarded-proto".to_string());
    headers.insert("x-real-ip".to_string());
    headers.insert("via".to_string());
    headers.insert("x-forwarded-port".to_string());
    headers.insert("x-forwarded-server".to_string());

    // Cloudflare headers
    //headers.insert("cf-connecting-ip".to_string()); // use this otherwise visit cf-cdn blocked.
    headers.insert("cf-ray".to_string());
    headers.insert("cf-ipcountry".to_string());
    headers.insert("cf-request-id".to_string());

    headers
}

pub async fn image_handler(req: Request, query: Option<HashMap<String, String>>) -> Result<Response> {
    let req_url = req.url()?;
    let domain = query.map_or(REGISTRY, |q|{
        match q.get("ns").map(|s| s.as_str()) {
            Some("gcr.io") => "gcr.io",
            Some("quay.io") => "quay.io",
            Some("ghcr.io") => "ghcr.io",
            Some("registry.k8s.io") => "registry.k8s.io",
            _ => REGISTRY,
        }
    });

    let full_url = format!("https://{}{}", domain, req_url.path());
    if let Ok(url) = Url::parse(&full_url) {                   
        return handler(req,  url).await;
    }
    return Response::error( "Not Found",404);
}

pub async fn handler(mut req: Request, uri: Url) -> Result<Response> {
    let hops = HOP_HEADERS.get_or_init(|| async {
        get_hop_headers().await
    }).await;
    let my_host = req.headers()
        .get("host")?
        .ok_or("Host header not found")?;
    let dst_host = uri.host_str().ok_or("Host not found")?;
    // build request
    let req_headers = Headers::new();
    for (key, value) in req.headers().entries() {
        if hops.contains(&key) {
            continue;
        }
        req_headers.set(&key, &value)?;
    }
    req_headers.set("host", dst_host)?;

    let mut req_init = RequestInit {
        method: req.method(),
        headers: req_headers,
        body: None,
        cf: CfProperties::default(),
        redirect: RequestRedirect::Manual,
    };
    // request body
    if let Ok(body) = req.bytes().await {
        if !body.is_empty() {
            req_init.body = Some(wasm_bindgen::JsValue::from(body));
        }
    }
    let new_req = Request::new_with_init(&uri.to_string(), &req_init)?;

    // send request
    let mut response = Fetch::Request(new_req).send().await?;

    // update response
    let resp_header = Headers::new();
    let status = response.status_code();

    for (key, value) in response.headers().entries() {
        if hops.contains(&key) {
            continue;
        }
        let new_value = match (status, key.as_str()){
            (301..= 308, "location") => {
                if value.starts_with('/') {
                    format!("/{}{}", uri.host().unwrap(), value)
                } else if value.starts_with("https://") {
                    if let Ok(url) = Url::parse(&value) {
                        if url.host_str().map_or(false, |host| host.contains("cloudflarestorage")) {
                            value
                        } else {
                            value.replace("https://", &format!("http://{}/", my_host))
                        }
                    } else {
                        value.replace("https://", &format!("https://{}/", my_host))
                    }
                } else {
                    value
                }         
            }
            (401, "www-authenticate") => {
                value.replace("https://", &format!("https://{}/", my_host))
            }
            _ => value,
        };
        resp_header.set(&key, &new_value)?;
    }
    let resp = match response.stream() {
        Err(_) => Response::builder()
            .with_status(status)
            .with_headers(resp_header)
            .empty(),
        Ok(stream) => Response::builder()
            .with_status(status)
            .with_headers(resp_header)
            .from_stream(stream)?,
    };

    return Ok(resp);
} 


pub async fn resolve_handler(mut req: Request, host: &String, query: Option<HashMap<String, String>>) -> Result<Response> {
    let hops = HOP_HEADERS.get_or_init(|| async {
        get_hop_headers().await
    }).await;
    let req_headers = Headers::new();
    for (key, value) in req.headers().entries() {
        if hops.contains(&key) {
            continue;
        }
        req_headers.set(&key, &value)?;
    }
    req_headers.set("host", host.as_str())?;

    let mut req_init = RequestInit {
        method: req.method(),
        headers: req_headers,
        body: None,
        cf: CfProperties::default(),
        redirect: RequestRedirect::Follow,
    };
    // body if exist
    if let Ok(body) = req.bytes().await {
        if !body.is_empty() {
            req_init.body = Some(wasm_bindgen::JsValue::from(body));
        }
    }
    let mut uri = format!("https://{}{}", host, req.path());
    if let Some(v) = query {
        uri.push('?');
        uri.push_str(v.iter()
            .map(|(k, v)| format!("{}={}", k, v))
            .collect::<Vec<_>>()
            .join("&")
            .as_str());
    }

    let new_req = Request::new_with_init(&uri, &req_init)?;
    console_debug!("DNS Request: {:?}", new_req);
    return Fetch::Request(new_req).send().await;
}
